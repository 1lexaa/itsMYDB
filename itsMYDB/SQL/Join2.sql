-- Приоритетное объединение
-- SELECT 
--      CONCAT( M.Surname, ' ', M.Name) AS [Сотрудник],
--      D.Name AS [Отдел]
-- FROM Managers M 
--     Join Departments D
--         ON M.Id_sec_dep = D.Id -- условие соединения. Если Id_sec_dep NULL, то условие ложно
-- 		ORDER BY M.Surname
		
-- Вывести ВСЕХ сотрудников, если нет совместительства, указать прочерк
-- Решение - приоритетное объединение: одна таблица выставляется приоритетной, т.е.
-- Из нее берется всё, независимо от условия объединения. Из другой таблицы берутся только то,
-- что "стыкуется" с первой
-- SELECT 
--      CONCAT( M.Surname, ' ', M.Name) AS [Сотрудник],
--      COALESCE( D.Name, '--' ) AS [Отдел]
-- FROM 
--     Managers M                 -- Левая таблица
--     LEFT Join Departments D    -- Приоритет левой таблицы
--         ON M.Id_sec_dep = D.Id -- Если в правой таблице есть совпадение, то есть данные
-- 		ORDER BY D.Name DESC

-- Также возможен приоритет правой таблицы: RIGHT JOIN
-- тогда все данные будут из правой таблицы, а из левой только те, которые "стыкуются"
-- остальные NULL. Рекомендуются эти значения NULL заменить на значения того же типа,
-- что и основные значения (строка, число, ...) для лучшей совместимости с языками програм.
-- COALESCE( arg1, arg2, arg3, ...) - возращает первый из аргументов, не равный NULL

-- INNER JOIN (или просто JOIN) - отбрасывает все несовпадения (по условию объединения)
-- в обоих таблицах, остаются те записи, которые и слева, и справа совпадают

SELECT 
     CONCAT( M.Surname, ' ', M.Name) AS [Сотрудник],
     CONCAT( COALESCE(Mayor.Name, '---'), ' ', Mayor.Surname) AS [Начальник]
FROM 
    Managers M                
    LEFT Join Managers Mayor    
        ON M.Id_chief = Mayor.Id
		ORDER BY M.Surname DESC

